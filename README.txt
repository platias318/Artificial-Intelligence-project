Description of Rubik's Cube Work
• Initially, we created a RubikSide class that implements each side of the cube along with its size and the initial color of its cubes (1=white, 2=blue, etc.). The class contains various necessary constructors (including copy constructors), getters, and setters, along with 2 methods (rotate sides) that are used in the subsequent classes.

• Next, we create our main class, State, which initializes the cube with its 6 sides (6 RubikSides, i.e., main, bottom, top, left, right, back) and initializes objects of various classes mentioned later. The class contains constructors (including copy constructors) as before, as well as necessary getters and setters for each side. Additionally, it includes objects for score and rootDist, which calculate the heuristic score and the distance of the current state (node) from the parent, respectively (for the implementation of A*). Furthermore, we have added methods for moving each column or side of the main side of the cube (each move changes the state of the cube normally, but we consistently see the same main side to maintain orientation), as well as the Scrumble method that calls the randomMove method and shuffles the cube. However, most importantly, we implement the first of our 2 heuristics, which simply counts, for the main side, how many moves each individual cube needs to reach its correct center, independent of the others. We do this for each side, setting each one as the main side (methods setLeftFaceMain, etc., implemented in another class). Therefore, the method is called 6 times for each side, and then we return to the initial main side. Our second heuristic counts the total number of cubes in the wrong position and divides it by 3 since each move affects 3 cubes. Additionally, we implement the getChildren method, which generates all possible moves from a specific state (12 in total), and for each child, it defines its distance from the root as the height of the parent from the root +1 and adds it to the heuristic score of the child. This is done for each of the 12 possible children. The isFinal method takes as a parameter the number of sides that we want to be solved and for each side checks if any cube is out of position. If it is, it continues with the remaining sides without increasing the int l counter, while it increases the counter if the side is correct. Finally, it checks if the number of actually solved sides is greater than or equal to the number of solved sides received as a parameter. The equals method takes an object parameter (State) and checks if each cube of one cube is similar to the corresponding cube in the cube received as a parameter. If yes, it returns True; otherwise, it returns False (we are sure that both State objects look at the same side-direction, i.e., with the white cube at the center since, as mentioned, the main side always remains the same while the cube's states (moves) change). Furthermore, the compareTo method checks which state has a higher heuristic score, and the print method prints the current state of the cube.

• Additionally, we implemented the RubikScrumbler class, which creates the 12 basic moves on a cube using 12 different methods, which it receives as a parameter from the constructor. Furthermore, in this class, we have created the RandomMove method mentioned earlier, which generates a random number from 0 to 11 and, depending on that number, performs the corresponding move on the cube.

Also, we constructed the FaceAction class, which allows us to set any desired side as the new main side, making the necessary changes to how we perceive the cube's direction (we mainly use this class as an assistant in implementing the movements of RubikScrumbler, where we wanted to keep the same main side).

Finally, we implemented the SpaceSearcher class, which contains the two search methods (A* and A* closed set) that are the same as those used in the tutorial (BestFs), with the difference that in the score of each heuristic, we also add the current height from the root and take it into account in our comparisons, as described in the A* algorithm.

Results of calling the AStarClosed function in the main for indicative K=1,2,3 (solved sides equal to one, two, three) are located in the folder named "texniti_photos" because they could not fit in the current file.